# -*- coding: utf-8 -*-
"""AMT_CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YM0hItkzWQfcl6xdCeFyMVIQYt5dRl8d
"""

import keras

from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Activation, Dropout, Flatten, Dense
from keras import backend as K
from keras.preprocessing.image import ImageDataGenerator,load_img,array_to_img,img_to_array
import numpy as np

# Extracting the data from the compressed folder                      
# from zipfile import ZipFile                                       
# file_name = "Drumkit_spectrograms.zip"                            
# with ZipFile(file_name,'r') as zip:                                
#  zip.extractall()

im_Height, im_Width = 128, 1034                                                 
training_dir = '/content/drive/My Drive/spectrograms/train_data'                
trainingSample =  486 # size of training data 75%                               

validation_dir = '/content/drive/My Drive/spectrograms/validation'              
validSample = 69 # size of validation data 15 %                                 

testing_dir = '/content/drive/My Drive/spectrograms/test_data'                  
testingSample =  101  # 10 %                                                    

num_epochs = 50                                                                 
'''
# dimensions of image                                                           
if K.image_data_format() == 'channels_first':                                   
  input_shape = (3,im_Width,im_Height)                                          
else:                                                                           
  input_shape = (im_Width,im_Height,3) '''                                         

datagen = ImageDataGenerator(1/255)                                                  

batch_size = 10                                                                 

train_data = datagen.flow_from_directory(training_dir,target_size=(256,256),batch_size=10, class_mode='binary')
val_data = datagen.flow_from_directory(validation_dir,target_size=(256,256),batch_size=10, class_mode='binary')
test_data = datagen.flow_from_directory(testing_dir,target_size=(256,256), batch_size=10, class_mode='binary')

#model definition                                                               

model = Sequential()                                                            

model.add(Conv2D(32,(3,3),input_shape=(256, 256, 3)))                         
model.add(Activation('relu'))                                                   
model.add(MaxPooling2D(pool_size=(2,2)))

model.add(Conv2D(32,(3,3)))                                                     
model.add(Activation('relu'))                                                   
model.add(MaxPooling2D(pool_size=(2,2)))                                        

model.add(Conv2D(32,(3,3)))                                                     
model.add(Activation('relu'))               
model.add(MaxPooling2D(pool_size=(2,2)))                                        

model.add(Flatten())
model.add(Dense(64))
model.add(Activation('relu'))
model.add(Dropout(0.2))
model.add(Dense(1))                                                             
model.add(Activation('sigmoid'))                                                

model.summary()                                                                 

model.compile(loss='binary_crossentropy',optimizer= 'adam',metrics=['accuracy'])

#train model

model.fit(train_data, steps_per_epoch=486//batch_size,epochs=50,validation_data=val_data,
          validation_steps=validSample)

#save model                                                                     
model.save_weights('instruclasf.h5')

#check model
impath = ''

im_pred = load_img(impath)     #test with piano                               
im_pred = img_to_array(im_pred)                                           
im_pred = np.array([im_pred])                                                   

res = model.predict(im_pred)        

if res[0][0]:
  print('piano')
else:
  print('drum')

